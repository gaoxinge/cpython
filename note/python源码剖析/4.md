## mem*

- [memcpy](http://www.runoob.com/cprogramming/c-function-memcpy.html)
- [memset](http://www.runoob.com/cprogramming/c-function-memset.html)
- [memmove](http://www.runoob.com/cprogramming/c-function-memmove.html)

## object

- [listobject.h](https://github.com/gaoxinge/cpython/blob/2.7/Include/listobject.h)
- [listobject.c](https://github.com/gaoxinge/cpython/blob/2.7/Objects/listobject.c)
- [tupleobject.h](https://github.com/gaoxinge/cpython/blob/2.7/Include/tupleobject.h)
- [tupleobject.c](https://github.com/gaoxinge/cpython/blob/2.7/Objects/tupleobject.c)

## tuple

```c
typedef struct {
    PyObject_VAR_HEAD
    PyObject *ob_item[1];
} PyTupleObject;
```

```c
#if PyTuple_MAXSAVESIZE > 0
static PyTupleObject *free_list[PyTuple_MAXSAVESIZE];
static int numfree[PyTuple_MAXSAVESIZE];
#endif
```

```c
PyObject *
PyTuple_New(register Py_ssize_t size)
{
    register PyTupleObject *op;
    Py_ssize_t i;
    if (size < 0) {
        PyErr_BadInternalCall();
        return NULL;
    }
    if (size == 0 && free_list[0]) {
        op = free_list[0];
        Py_INCREF(op);
        return (PyObject *) op;
    }
    if (size < PyTuple_MAXSAVESIZE && (op = free_list[size]) != NULL) {
        free_list[size] = (PyTupleObject *) op->ob_item[0];
        numfree[size]--;
        _Py_NewReference((PyObject *)op);
    }
    else
    {
        Py_ssize_t nbytes = size * sizeof(PyObject *);
        /* Check for overflow */
        if (nbytes / sizeof(PyObject *) != (size_t)size ||
            (nbytes > PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)))
        {
            return PyErr_NoMemory();
        }

        op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size);
        if (op == NULL)
            return NULL;
    }
    for (i=0; i < size; i++)
        op->ob_item[i] = NULL;
    if (size == 0) {
        free_list[0] = op;
        ++numfree[0];
        Py_INCREF(op);          /* extra INCREF so that this is never freed */
    }
    _PyObject_GC_TRACK(op);
    return (PyObject *) op;
}
```